<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Анализатор звука с коррекцией фона</title>
    <style>
        :root {
            --signal-color: #FF0000;       /* Ярко-красный */
            --background-color: #00AA00;    /* Ярко-зелёный */
            --integral-color: #0000FF;     /* Ярко-синий */
            --start-color: #FF00FF;       /* Фиолетовый для старта */
            --end-color: #FF69B4;        /* Розовый для финиша */
            --cutoff-color: #FFA500;     /* Оранжевый для момента отсечения */
            --grid-color: #E0E0E0;         /* Светло-серая сетка */
            --axis-color: #888;            /* Серые оси */
            --secondary-color: #f0f2ff;
            --accent-color: #ff6b6b;
            --text-color: #333;
            --light-text: #666;
            --border-color: #ddd;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
            color: var(--text-color);
            line-height: 1.6;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: var(--text-color);
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        canvas {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: white;
            margin: 20px auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        #status {
            color: var(--text-color);
            font-weight: 500;
            margin: 15px 0;
            min-height: 24px;
        }
        
        #status.recording {
            color: var(--accent-color);
            animation: blink 1.5s infinite;
        }
        
        #timer {
            font-size: 18px;
            font-weight: bold;
            color: var(--text-color);
            margin: 10px 0;
        }
        
        @keyframes blink {
            50% { opacity: 0.7; }
        }
        
        #graph-title {
            font-weight: 600;
            color: var(--text-color);
            font-size: 20px;
            margin: 25px 0 10px;
            display: none;
        }
        
        button {
            background-color: #4a6bff;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            box-shadow: 0 2px 10px rgba(74, 107, 255, 0.3);
        }
        
        button:hover {
            background-color: #3a5bef;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(74, 107, 255, 0.4);
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .info-box {
            background-color: var(--secondary-color);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: left;
            border-left: 4px solid #4a6bff;
        }
        
        .legend {
            margin-top: 10px;
            font-size: 14px;
            color: #111827;
        }
        .legend span {
            margin: 0 12px;
            display: inline-flex;
            align-items: center;
        }
        .legend .color-box {
            display: inline-block;
            width: 18px;
            height: 12px;
            margin-right: 6px;
            border-radius: 3px;
        }

        .results {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--secondary-color);
            border-radius: 8px;
            text-align: center;
            display: none;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            canvas {
                width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Анализ интенсивности звука с коррекцией фона</h1>
        
        <div class="info-box">
            <strong>Как использовать:</strong> Нажмите кнопку "Начать запись", разрешите доступ к микрофону. 
            После 15 секунд записи вы увидите график, где:
            <ul>
                <li><span style="color: var(--signal-color); font-weight: bold;">Красная линия</span> - очищенный сигнал</li>
                <li><span style="color: var(--background-color); font-weight: bold;">Зелёная линия</span> - фоновый шум</li>
                <li><span style="color: var(--integral-color); font-weight: bold;">Синяя линия</span> - интегральная кривая</li>
                <li><span style="color: var(--start-color); font-weight: bold;">Фиолетовая линия</span> - момент старта сигнала</li>
                <li><span style="color: var(--end-color); font-weight: bold;">Розовая линия</span> - момент окончания сигнала (99% интеграла)</li>
                <li><span style="color: var(--cutoff-color); font-weight: bold;">Оранжевая линия</span> - момент отсечения (старт + 1 сек)</li>
            </ul>
        </div>
        
        <button id="startBtn">Начать запись (15 сек)</button>
        <div id="timer"></div>
        <p id="status">Готов к записи</p>
        
        <div class="results" id="results">
            <h3>Результаты анализа:</h3>
            <p id="start-time-result">Время старта: - сек</p>
            <p id="end-time-result">Время финиша: - сек</p>
            <p id="intensity-result">Интенсивность в точке отсечения: -</p>
        </div>
        
        <p id="graph-title">График интенсивности звука</p>
        <canvas id="graph" width="800" height="400"></canvas>
        <div class="legend">
            <span><i class="color-box" style="background: var(--signal-color);"></i> Сигнал</span>
            <span><i class="color-box" style="background: var(--background-color);"></i> Фон</span>
            <span><i class="color-box" style="background: var(--integral-color);"></i> Интеграл</span>
            <span><i class="color-box" style="background: var(--start-color);"></i> Старт</span>
            <span><i class="color-box" style="background: var(--end-color);"></i> Финиш</span>
            <span><i class="color-box" style="background: var(--cutoff-color);"></i> Отсечение</span>
        </div>
    </div>

    <script>
        // Проверка поддержки Web Audio API
        if (!window.AudioContext && !window.webkitAudioContext) {
            document.getElementById('status').textContent = "Ваш браузер не поддерживает Web Audio API";
            document.getElementById('startBtn').disabled = true;
        }

        const DURATION = 15;
        const SAMPLE_RATE = 44100;
        const CHUNK_SIZE = 1024;

        const startBtn = document.getElementById('startBtn');
        const timerElement = document.getElementById('timer');
        const statusElement = document.getElementById('status');
        const graphTitle = document.getElementById('graph-title');
        const canvas = document.getElementById('graph');
        const ctx = canvas.getContext('2d');
        const resultsElement = document.getElementById('results');
        const startTimeResult = document.getElementById('start-time-result');
        const endTimeResult = document.getElementById('end-time-result');
        const intensityResult = document.getElementById('intensity-result');

        let audioContext;
        let analyser;
        let microphone;
        let recordingStartTime;
        let recordingInterval;
        let audioData = [];
        let backgroundNoise = [];
        let isRecording = false;

        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: SAMPLE_RATE
                });
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                return true;
            } catch (e) {
                console.error("Ошибка инициализации аудио:", e);
                statusElement.textContent = "Ошибка инициализации аудио";
                return false;
            }
        }

        async function startRecording() {
            try {
                if (!audioContext && !initAudio()) {
                    return;
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                
                recordingStartTime = audioContext.currentTime;
                isRecording = true;
                audioData = [];
                backgroundNoise = [];
                
                startBtn.disabled = true;
                statusElement.textContent = "Идёт запись...";
                statusElement.classList.add('recording');
                graphTitle.style.display = 'none';
                resultsElement.style.display = 'none';
                
                processAudio();
                
                let secondsLeft = DURATION;
                updateTimer(secondsLeft);
                
                recordingInterval = setInterval(() => {
                    secondsLeft--;
                    updateTimer(secondsLeft);
                    
                    if (secondsLeft <= 0) {
                        stopRecording();
                    }
                }, 1000);
                
            } catch (error) {
                console.error('Ошибка при записи:', error);
                statusElement.textContent = "Ошибка: " + error.message;
                resetRecordingState();
            }
        }

        function processAudio() {
            if (!isRecording) return;
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);
            
            const timestamp = audioContext.currentTime - recordingStartTime;
            const normalizedData = Array.from(dataArray).map(x => (x - 128) / 128);
            
            audioData.push({
                time: timestamp,
                data: normalizedData
            });
            
            if (timestamp < 2) {
                backgroundNoise.push({
                    x: timestamp / DURATION,
                    y: calculateRMS(normalizedData)
                });
            }
            
            requestAnimationFrame(processAudio);
        }

        function calculateRMS(data) {
            let sum = 0;
            for (let i = 0; i < data.length; i++) {
                sum += data[i] * data[i];
            }
            return Math.sqrt(sum / data.length);
        }

        function stopRecording() {
            clearInterval(recordingInterval);
            isRecording = false;
            
            if (microphone) {
                microphone.disconnect();
            }
            
            statusElement.textContent = "Анализ данных...";
            statusElement.classList.remove('recording');
            
            setTimeout(() => {
                processAndDrawData();
                resetRecordingState();
            }, 500);
        }

        function findSignalStart(integralData, sampleRate) {
            const SMOOTHING_WINDOW = 0.5;
            const THRESHOLD_FACTOR = 5;
            const MIN_DURATION = 0.3;
            const START_IGNORE_TIME = 0.5;

            const windowSize = Math.floor(SMOOTHING_WINDOW * sampleRate);
            let startIndex = -1;

            let means = [], stdDevs = [];
            for (let i = 0; i < integralData.length; i++) {
                const start = Math.max(0, i - windowSize);
                const window = integralData.slice(start, i).map(p => p.y);
                const mean = window.reduce((a, b) => a + b, 0) / window.length;
                const stdDev = window.length > 1 ? 
                    Math.sqrt(window.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (window.length - 1)) : 0;
                
                means.push(mean);
                stdDevs.push(stdDev);
            }

            const ignoreIndex = Math.floor(START_IGNORE_TIME * sampleRate);
            for (let i = ignoreIndex; i < integralData.length; i++) {
                const threshold = means[i] + THRESHOLD_FACTOR * stdDevs[i];
                
                if (integralData[i].y > threshold) {
                    let isSignal = true;
                    for (let j = i; j < Math.min(i + MIN_DURATION * sampleRate, integralData.length); j++) {
                        if (integralData[j].y <= threshold) {
                            isSignal = false;
                            break;
                        }
                    }
                    if (isSignal) {
                        startIndex = i;
                        break;
                    }
                }
            }

            return startIndex >= 0 ? integralData[startIndex].x * DURATION : -1;
        }

        function findSignalEnd(integralData, sampleRate, startTime) {
            if (startTime < 0) return -1;

            const maxIntegralValue = Math.max(...integralData.map(p => p.y));
            if (maxIntegralValue <= 0) return -1;

            const targetValue = 0.99 * maxIntegralValue;
            let endIndex = -1;

            for (let i = 0; i < integralData.length; i++) {
                if (integralData[i].y >= targetValue) {
                    endIndex = i;
                    break;
                }
            }

            return endIndex >= 0 ? integralData[endIndex].x * DURATION : -1;
        }

        function processAndDrawData() {
            if (audioData.length === 0) {
                statusElement.textContent = "Нет данных для анализа";
                return;
            }
            
            try {
                const avgBackgroundNoise = backgroundNoise.reduce((sum, point) => sum + point.y, 0) / backgroundNoise.length;
                
                const originalSignal = [];
                const backgroundSignal = [];
                const timeStep = DURATION / audioData.length;
                
                for (let i = 0; i < audioData.length; i++) {
                    const point = audioData[i];
                    const intensity = calculateRMS(point.data);
                    
                    originalSignal.push(intensity);
                    backgroundSignal.push({
                        x: point.time / DURATION,
                        y: avgBackgroundNoise
                    });
                }
                
                const integralSignal = calculateIntegralCurve(originalSignal, avgBackgroundNoise);
                
                const sampleRate = audioData.length / DURATION;
                const startTime = findSignalStart(integralSignal, sampleRate);
                const endTime = findSignalEnd(integralSignal, sampleRate, startTime);
                const cutoffTime = startTime > 0 ? startTime + 1 : -1;
                
                console.log("Start time:", startTime, "End time:", endTime, "Cutoff time:", cutoffTime);
                
                const maxIntegralValue = Math.max(...integralSignal.map(p => p.y));
                const normalizedIntegral = integralSignal.map(p => ({
                    x: p.x,
                    y: maxIntegralValue > 0 ? p.y / maxIntegralValue : 0
                }));
                
                // Вычисляем интенсивность в точке отсечения
                let cutoffIntensity = -1;
                if (cutoffTime > 0 && cutoffTime < DURATION) {
                    const cutoffIndex = Math.floor(cutoffTime / timeStep);
                    if (cutoffIndex >= 0 && cutoffIndex < normalizedIntegral.length) {
                        cutoffIntensity = normalizedIntegral[cutoffIndex].y;
                    }
                }
                
                // Показываем результаты анализа
                showResults(startTime, endTime, cutoffIntensity);
                
                graphTitle.style.display = 'block';
                drawGraphWithBackground(
                    originalSignal, 
                    backgroundSignal, 
                    normalizedIntegral,
                    timeStep, 
                    startTime, 
                    endTime, 
                    cutoffTime
                );
                statusElement.textContent = "Анализ завершен";
            } catch (error) {
                console.error('Ошибка при обработке данных:', error);
                statusElement.textContent = "Ошибка анализа данных";
            }
        }

        function showResults(startTime, endTime, cutoffIntensity) {
            resultsElement.style.display = 'block';
            
            if (startTime > 0) {
                startTimeResult.textContent = `Время старта: ${startTime.toFixed(2)} сек`;
            } else {
                startTimeResult.textContent = 'Время старта: не обнаружено';
            }
            
            if (endTime > 0) {
                endTimeResult.textContent = `Время финиша: ${endTime.toFixed(2)} сек`;
            } else {
                endTimeResult.textContent = 'Время финиша: не обнаружено';
            }
            
            if (cutoffIntensity !== undefined && cutoffIntensity >= 0) {
                intensityResult.textContent = `Интенсивность в точке отсечения: ${cutoffIntensity.toFixed(4)}`;
            } else {
                intensityResult.textContent = 'Интенсивность в точке отсечения: не доступно';
            }
        }

        function calculateIntegralCurve(signal, backgroundLevel) {
            const integralPoints = [];
            let integralValue = 0;
            const timeStep = DURATION / signal.length;
            
            for (let i = 0; i < signal.length; i++) {
                const signalValue = Math.max(0, signal[i] - backgroundLevel * 0.8);
                integralValue += signalValue * timeStep;
                
                integralPoints.push({
                    x: i * timeStep / DURATION,
                    y: integralValue
                });
            }
            
            return integralPoints;
        }

        function updateTimer(seconds) {
            timerElement.textContent = `Осталось: ${seconds} сек`;
        }

        function resetRecordingState() {
            startBtn.disabled = false;
            timerElement.textContent = '';
        }

        function drawGraphWithBackground(
            originalData, 
            backgroundData, 
            integralData,
            timeStep, 
            startTime, 
            endTime, 
            cutoffTime
        ) {
            if (!originalData || !backgroundData || !integralData || !timeStep) {
                console.error('Некорректные параметры для drawGraphWithBackground');
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Сетка и оси
            ctx.beginPath();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-color').trim();
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 1; i += 0.1) {
                const y = canvas.height - i * canvas.height;
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            
            for (let i = 0; i <= DURATION; i += 1) {
                const x = (i / DURATION) * canvas.width;
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            ctx.stroke();

            ctx.beginPath();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis-color').trim();
            ctx.lineWidth = 2;
            ctx.moveTo(0, canvas.height);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.moveTo(0, 0);
            ctx.lineTo(0, canvas.height);
            ctx.stroke();

            // Фон (зелёный)
            ctx.beginPath();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--background-color').trim();
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 3]);
            for (let i = 0; i < backgroundData.length; i++) {
                const x = backgroundData[i].x * canvas.width;
                const y = canvas.height - backgroundData[i].y * canvas.height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Очищенный сигнал (красный)
            ctx.beginPath();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--signal-color').trim();
            ctx.lineWidth = 3;
            for (let i = 0; i < backgroundData.length; i++) {
                const originalIndex = Math.round(backgroundData[i].x * originalData.length);
                const originalValue = originalData[Math.min(originalIndex, originalData.length - 1)];
                const backgroundValue = backgroundData[i].y;
                const cleanedValue = Math.max(0, originalValue - backgroundValue * 0.8);
                
                const x = backgroundData[i].x * canvas.width;
                const y = canvas.height - cleanedValue * canvas.height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Интегральная кривая (синяя)
            ctx.beginPath();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--integral-color').trim();
            ctx.lineWidth = 3;
            ctx.setLineDash([3, 3]);
            for (let i = 0; i < integralData.length; i++) {
                const x = integralData[i].x * canvas.width;
                const y = canvas.height - integralData[i].y * canvas.height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Отметка старта сигнала
            if (startTime > 0 && startTime < DURATION) {
                const startX = (startTime / DURATION) * canvas.width;
                
                ctx.beginPath();
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--start-color').trim();
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.moveTo(startX, 0);
                ctx.lineTo(startX, canvas.height);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.font = '14px "Segoe UI", sans-serif';
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--start-color').trim();
                ctx.textAlign = 'center';
                ctx.fillText(`Старт - ${startTime.toFixed(1)} сек`, startX, canvas.height + 20);
            }

            // Отметка финиша сигнала (99% интеграла)
            if (endTime > 0 && endTime < DURATION) {
                const endX = (endTime / DURATION) * canvas.width;
                
                ctx.beginPath();
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--end-color').trim();
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.moveTo(endX, 0);
                ctx.lineTo(endX, canvas.height);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.font = '14px "Segoe UI", sans-serif';
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--end-color').trim();
                ctx.textAlign = 'center';
                ctx.fillText(`Финиш (99%) - ${endTime.toFixed(1)} сек`, endX, canvas.height + 40);
            }

            // Отметка момента отсечения
            if (cutoffTime > 0 && cutoffTime < DURATION && startTime > 0) {
                const cutoffX = (cutoffTime / DURATION) * canvas.width;
                
                ctx.beginPath();
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--cutoff-color').trim();
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.moveTo(cutoffX, 0);
                ctx.lineTo(cutoffX, canvas.height);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.font = '14px "Segoe UI", sans-serif';
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cutoff-color').trim();
                ctx.textAlign = 'center';
                ctx.fillText(`Отсечение - ${cutoffTime.toFixed(1)} сек`, cutoffX, canvas.height + 60);
            }

            // Подписи осей
            ctx.font = '12px "Segoe UI", sans-serif';
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
            
            ctx.textAlign = 'center';
            for (let i = 0; i <= DURATION; i += 1) {
                const x = (i / DURATION) * canvas.width;
                ctx.fillText(i.toString(), x, canvas.height - 8);
            }
            ctx.fillText('Время (секунды)', canvas.width / 2, canvas.height - 15);
            
            ctx.textAlign = 'right';
            for (let i = 0; i <= 1; i += 0.2) {
                const y = canvas.height - i * canvas.height;
                ctx.fillText(i.toFixed(1), 30, y + 4);
            }
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Нормированная интенсивность', 0, 0);
            ctx.restore();
        }

        document.addEventListener('DOMContentLoaded', () => {
            startBtn.addEventListener('click', startRecording);
        });
    </script>
</body>
</html>